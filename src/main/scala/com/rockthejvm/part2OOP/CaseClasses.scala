package com.rockthejvm.part2OOP

object CaseClasses {

  // lightweight data structures
  // case provides additional properties to a typical class
  case class Person(name: String, age: Int) {
    // do some other stuff
  }

  // 1. Class arguments become fields
  val daniel = new Person("Daniel", 99)
  val danielsAge = daniel.age

  // 2. Some methods automatically generated by the compiler e.g., toString, equals, and hashCode
  val danielToString = daniel.toString
  val danielDuped = new Person("Daniel", 99)
  val isSameDaniel = daniel == danielDuped // == operator is used to signify equality

  // 3. Utility methods e.g., copy
  val danielYounger = daniel.copy(age = 78) // creates a new instance of Person. Everything stays the same as original Daniel apart from the updated params (age)

  // 4. Companion objects automatically generated by the compiler
  val thePesronSingleton = Person
  val daniel_v2 = Person.apply("Daniel", 99) // "constructor" - the apply method can be omitted

  // 5. Serializable - an instance of Person from in memory representation can be turned into a series of bytes/ characters to be transferred to another jvm
  // use-case: Akka

  // 6. Extracter patterns can be used for *Pattern Matching*

  // case classes MUST take arguments - a case object can be used as this is a single instance
  case object UnitedKingdom {
    // fields and methods
    def name: String = "The United Kingdom"
  }

  case class CCWithArgListNoArgs() // this is legal use-case: when using generic types

  /* Exercise */
  // Update LList using case classes



  def main(args: Array[String]): Unit = {
    println(daniel) // Person(Daniel, 99) - the string representation of daniel (without "case" this would look like com.rockthejvm.part2oop.caseClassesÂ¢Person...)
    println(isSameDaniel) // true  (without case this would be false as == would signify reference equality - do they point to the same object in memory)
  }

}
